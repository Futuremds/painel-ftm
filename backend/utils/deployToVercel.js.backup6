const path = require('path');
const fs = require('fs-extra');
const { execSync } = require('child_process');
const axios = require('axios');

const NETLIFY_TOKEN = process.env.NETLIFY_TOKEN;

console.log('=== DEBUG: deployToVercel.js carregado ===');
console.log('NETLIFY_TOKEN dispon√≠vel:', NETLIFY_TOKEN ? 'SIM' : 'N√ÉO');

// Fun√ß√£o para aguardar um tempo antes de tentar novamente
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Fun√ß√£o para gerar nome √∫nico para o site
function generateUniqueSiteName(baseName) {
  const timestamp = Date.now();
  const randomSuffix = Math.random().toString(36).substring(2, 8);
  return `${baseName}-${timestamp}-${randomSuffix}`;
}

// Fun√ß√£o para buscar site existente na Netlify
async function findNetlifySite(siteName) {
  try {
    console.log(`üîç Buscando site ${siteName} na Netlify...`);

    const response = await axios.get('https://api.netlify.com/api/v1/sites', {
      headers: {
        'Authorization': `Bearer ${NETLIFY_TOKEN}`
      }
    });

    const sites = response.data;
    const site = sites.find(s => s.name === siteName || s.url.includes(siteName));

    if (site) {
      console.log('‚úÖ Site encontrado na Netlify:', site.url);
      return {
        id: site.id,
        url: site.url,
        custom_domain: site.custom_domain
      };
    } else {
      console.log('‚ùå Site n√£o encontrado na Netlify');
      return null;
    }
  } catch (error) {
    console.error('‚ùå Erro ao buscar site na Netlify:', error.response?.data || error.message);
    return null;
  }
}

// Fun√ß√£o para criar site na Netlify com retry e fallback
async function createNetlifySite(siteName, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Criando site ${siteName} na Netlify... (tentativa ${attempt}/${maxRetries})`);

      // Validar se o nome do site √© v√°lido para a Netlify
      let cleanName = siteName
        .toLowerCase()
        .replace(/[^a-z0-9-_]/g, '')  // Remove caracteres inv√°lidos
        .replace(/^-+|-+$/g, '')      // Remove h√≠fens do in√≠cio e fim
        .replace(/-+/g, '-')          // M√∫ltiplos h√≠fens viram um s√≥
        .replace(/_+/g, '_');         // M√∫ltiplos underscores viram um s√≥

      // Se ap√≥s a limpeza o nome estiver vazio, usar o nome original
      if (!cleanName || cleanName.length < 1) {
        cleanName = siteName.toLowerCase().replace(/[^a-z0-9]/g, '');
      }

      // Se ainda estiver vazio, usar um nome padr√£o
      if (!cleanName || cleanName.length < 1) {
        cleanName = 'site-ftm';
      }

      // Na √∫ltima tentativa, usar um nome √∫nico para evitar conflitos
      if (attempt === maxRetries) {
        cleanName = generateUniqueSiteName(cleanName);
        console.log(`Usando nome √∫nico na √∫ltima tentativa: ${cleanName}`);
      }

      console.log(`Nome original: ${siteName}`);
      console.log(`Nome limpo para Netlify: ${cleanName}`);

      const response = await axios.post('https://api.netlify.com/api/v1/sites', {
        name: cleanName
      }, {
        headers: {
          'Authorization': `Bearer ${NETLIFY_TOKEN}`,
          'Content-Type': 'application/json'
        }
      });

      const siteData = response.data;
      console.log('‚úÖ Site criado na Netlify:', siteData.url);
      return {
        id: siteData.id,
        url: siteData.url,
        custom_domain: siteData.custom_domain
      };

    } catch (error) {
      console.error(`‚ùå Erro na tentativa ${attempt}:`, error.response?.data || error.message);
      
      if (error.response?.status === 429) {
        const waitTime = attempt * 15; // 15, 30, 45 segundos
        console.log(`‚è≥ Rate limit atingido. Aguardando ${waitTime} segundos...`);
        await sleep(waitTime * 1000);
        
        // Se for a √∫ltima tentativa e ainda for rate limit, lan√ßar erro espec√≠fico
        if (attempt === maxRetries) {
          throw new Error('RATE_LIMIT_EXCEEDED: Limite de requisi√ß√µes da Netlify atingido ap√≥s todas as tentativas');
        }
        continue;
      }
      
      if (attempt === maxRetries) {
        throw error;
      }
      
      console.log(`‚è≥ Aguardando 10 segundos antes da pr√≥xima tentativa...`);
      await sleep(10000);
    }
  }
  
  // Se chegou aqui, todas as tentativas falharam
  throw new Error('Falha ao criar site na Netlify ap√≥s todas as tentativas');
}

// Fun√ß√£o para criar ZIP dos arquivos do site
async function createSiteZip(siteDir, siteName) {
  try {
    console.log('üì¶ Criando arquivo ZIP dos arquivos do site...');

    const timestamp = Date.now();
    const zipFileName = `deploy-${timestamp}.zip`;
    const zipPath = path.join(siteDir, zipFileName);

    // Criar ZIP com todos os arquivos do site
    execSync(`zip -r ${zipFileName} . -x "*.git*" "*.zip"`, {
      cwd: siteDir,
      stdio: 'inherit'
    });

    console.log(`‚úÖ ZIP criado: ${zipPath}`);
    return zipPath;
  } catch (error) {
    console.error('‚ùå Erro ao criar ZIP:', error.message);
    throw error;
  }
}

// Fun√ß√£o para fazer deploy do ZIP na Netlify com retry
async function deployZipToNetlify(zipPath, siteId, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üöÄ Fazendo deploy do ZIP na Netlify... (tentativa ${attempt}/${maxRetries})`);

      // Usar curl para fazer upload do ZIP
      const deployCommand = `curl -H "Authorization: Bearer ${NETLIFY_TOKEN}" -H "Content-Type: application/zip" --data-binary "@${zipPath}" https://api.netlify.com/api/v1/sites/${siteId}/deploys`;

      const result = execSync(deployCommand, {
        encoding: 'utf8',
        stdio: 'pipe'
      });

      const deployData = JSON.parse(result);
      console.log('‚úÖ Deploy iniciado na Netlify!');
      console.log('üìä Status do deploy:', deployData.state);
      console.log('üîó URL do deploy:', deployData.deploy_url);

      return deployData;

    } catch (error) {
      console.error(`‚ùå Erro na tentativa ${attempt}:`, error.message);
      
      if (attempt === maxRetries) {
        throw error;
      }
      
      console.log(`‚è≥ Aguardando 10 segundos antes da pr√≥xima tentativa...`);
      await sleep(10000);
    }
  }
}

// Fun√ß√£o para verificar status do deploy
async function checkDeployStatus(siteId, deployId) {
  try {
    console.log(' Verificando status do deploy...');

    const response = await axios.get(`https://api.netlify.com/api/v1/sites/${siteId}/deploys/${deployId}`, {
      headers: {
        'Authorization': `Bearer ${NETLIFY_TOKEN}`
      }
    });

    const deployData = response.data;
    console.log(` Status atual: ${deployData.state}`);

    if (deployData.state === 'ready') {
      console.log('‚úÖ Deploy conclu√≠do com sucesso!');
      console.log('üåê Site publicado em:', deployData.deploy_url);
    } else if (deployData.state === 'error') {
      console.log('‚ùå Erro no deploy:', deployData.error_message);
    } else {
      console.log('‚è≥ Deploy ainda em andamento...');
    }

    return deployData;
  } catch (error) {
    console.error('‚ùå Erro ao verificar status:', error.message);
    throw error;
  }
}

// Fun√ß√£o principal de deploy
async function deployToVercel(params) {
  try {
    console.log('üöÄ Iniciando deploy direto na Netlify...');

    // Extrair par√¢metros
    const { siteName, siteDir } = params;

    if (!siteName) {
      throw new Error('siteName √© obrigat√≥rio');
    }

    if (!siteDir) {
      throw new Error('siteDir √© obrigat√≥rio');
    }

    console.log('üìÅ Diret√≥rio do site:', siteDir);
    console.log('üè∑Ô∏è Nome do site:', siteName);

    // 1. Buscar site existente ou criar novo
    console.log('\n=== PASSO 1: Verificando site existente ===');
    let siteData = await findNetlifySite(siteName);

    if (!siteData) {
      console.log('Site n√£o encontrado, criando novo...');
      try {
        siteData = await createNetlifySite(siteName);
      } catch (createError) {
        console.error('‚ùå Erro ao criar site:', createError.message);
        
        // Se for rate limit, retornar erro espec√≠fico
        if (createError.message.includes('RATE_LIMIT_EXCEEDED')) {
          return {
            success: false,
            error: 'RATE_LIMIT_EXCEEDED: Limite de requisi√ß√µes da Netlify atingido. Tente novamente em alguns minutos.'
          };
        }
        
        throw createError;
      }
    }

    // Verificar se siteData foi criado com sucesso
    if (!siteData || !siteData.id) {
      throw new Error('Falha ao criar ou obter dados do site na Netlify');
    }

    // 2. Criar ZIP dos arquivos
    console.log('\n=== PASSO 2: Criando arquivo ZIP ===');
    const zipPath = await createSiteZip(siteDir, siteName);

    // 3. Fazer deploy do ZIP
    console.log('\n=== PASSO 3: Fazendo deploy dos arquivos ===');
    const deployData = await deployZipToNetlify(zipPath, siteData.id);

    // 4. Verificar status inicial
    console.log('\n=== PASSO 4: Verificando status inicial ===');
    await checkDeployStatus(siteData.id, deployData.id);

    // 5. Limpar arquivo ZIP
    console.log('\n=== PASSO 5: Limpeza ===');
    fs.removeSync(zipPath);
    console.log('üßπ Arquivo ZIP removido');

    // 6. Retornar informa√ß√µes do site
    console.log('\n=== ‚úÖ DEPLOY CONCLU√çDO ===');
    console.log('üåê Site URL:', siteData.url);
    console.log('üîó Deploy URL:', deployData.deploy_url);

    return {
      success: true,
      data: {
        id: deployData.id,
        url: siteData.url,
        custom_domain: siteData.custom_domain,
        deploy_url: deployData.deploy_url
      }
    };

  } catch (error) {
    console.error('‚ùå Erro no deploy:', error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

module.exports = { deployToVercel };
